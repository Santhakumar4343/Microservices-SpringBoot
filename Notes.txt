
1) Eureka Server is contains all services at one place 
   dependency we use eureka service registry  
   ** if we run eukrea server on port 8761 we dont need to explicitly register the services they will add automatically 
  
2)Admin server is responsible for get all the services health checks,logs,heapdump and other things 
3)Zipkin server is used for the traces of our applcation and apis how much time it will take to completed the request 
4)Services communication 
  Resttemplete -> to call the external service with url that is not part of our application 
  webclient -> call the external service with the url 
  feignclient -> communication between the services in the same application using the service name without any url 
  
  
üìò Spring Boot Microservices ‚Äì Core Concepts & Tools
1Ô∏è‚É£ Eureka Server (Service Registry)

What it is:
Eureka is a Service Registry that acts like a phone book for microservices.
Each service registers itself with Eureka, and Eureka keeps track of all running instances.

Key Points:

Central place where all microservices register themselves.

Removes the need to hardcode hostnames/ports in your code.

Services can discover each other by service name instead of URL.

Typically runs on port 8761 by default.

Dependencies:
Add in pom.xml:

<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
</dependency>


Note:
Services must also include the Eureka client dependency to register.
(‚ö†Ô∏è Services don‚Äôt register automatically unless they‚Äôre configured as Eureka clients with @EnableEurekaClient or @EnableDiscoveryClient).

2Ô∏è‚É£ Spring Boot Admin Server

What it is:
A dashboard to monitor and manage microservices.

Responsibilities:

Displays health checks of services.

Provides access to logs, metrics, heap dumps, and thread dumps.

Useful for operational visibility.

Integrates with Spring Actuator endpoints (/actuator/health, /actuator/metrics, etc.).

Dependencies:

<dependency>
    <groupId>de.codecentric</groupId>
    <artifactId>spring-boot-admin-starter-server</artifactId>
</dependency>


Note:
Each service must expose Actuator endpoints and register with the Admin Server.

3Ô∏è‚É£ Zipkin Server (Distributed Tracing)

What it is:
Zipkin is a distributed tracing system.
It tracks requests as they move through multiple services in your system.

Why we need it:

Helps analyze latency problems (which service/endpoint is slow).

Shows trace of API calls across microservices.

Helps debug issues in complex service-to-service calls.

Dependencies:

<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-zipkin</artifactId>
</dependency>


Works with: Sleuth (adds trace IDs and span IDs in logs for correlation).

4Ô∏è‚É£ Service Communication Methods
üîπ RestTemplate

What: Old, synchronous HTTP client.

When: To call an external API (not part of your microservices system).

Example:

RestTemplate restTemplate = new RestTemplate();
String response = restTemplate.getForObject("https://api.example.com/data", String.class);

üîπ WebClient

What: Modern, non-blocking HTTP client (Reactive).

When: To call external APIs (just like RestTemplate), but with better performance and async support.

Example:

WebClient webClient = WebClient.create();
String response = webClient.get()
                           .uri("https://api.example.com/data")
                           .retrieve()
                           .bodyToMono(String.class)
                           .block(); // block() for sync

üîπ Feign Client

What: Declarative REST client provided by Spring Cloud.

When: To call internal microservices by service name (via Eureka) ‚Üí no need to hardcode URLs.

Example:

@FeignClient(name = "order-service") // service name from Eureka
public interface OrderClient {
    @GetMapping("/orders/{id}")
    Order getOrderById(@PathVariable("id") String id);
}


Usage in Service:

@Autowired
private OrderClient orderClient;

public Order fetchOrder(String id) {
    return orderClient.getOrderById(id);
}

5Ô∏è‚É£ Quick Comparison ‚Äì RestTemplate vs WebClient vs Feign
Feature	RestTemplate	WebClient	Feign Client
Type	Blocking	Non-blocking (Reactive)	Declarative
Best for	Simple legacy APIs	High-performance, async	Service-to-service calls
Needs URL?	Yes	Yes	No (uses service name from Eureka)
Status	Deprecated	Recommended	Recommended with Spring Cloud
6Ô∏è‚É£ Summary (Golden Rules)

Use Eureka ‚Üí for service discovery.

Use Spring Boot Admin ‚Üí for monitoring services.

Use Zipkin ‚Üí for distributed tracing and debugging.

Use RestTemplate/WebClient ‚Üí for calling external APIs.

Use Feign Client ‚Üí for internal microservice-to-microservice communication.


üìå Load Balancing in Spring Boot with Ribbon (Server-Side)
üîë Key Points

Ribbon Basics

Ribbon is a client-side load balancer (deprecated in newer Spring versions, replaced by Spring Cloud LoadBalancer).

It automatically distributes traffic across multiple service instances registered in Eureka (service discovery).

Works with RestTemplate or Feign Client.

How It Works

Service discovery (Eureka) provides a list of instances of a service.

Ribbon maintains a local cache of available service instances.

Ribbon applies a load balancing algorithm (e.g., round-robin, random, weighted response time) to pick one instance for each request.

Ribbon with RestTemplate

@Bean
@LoadBalanced
public RestTemplate restTemplate() {
    return new RestTemplate();
}


‚Üí Now when you call http://SERVICE-NAME/endpoint, Ribbon resolves it to one of the available instances.

Load Balancing Strategies

Default ‚Üí Round Robin.

Custom ‚Üí can configure rules like RandomRule, BestAvailableRule, ZoneAvoidanceRule.

Fault Tolerance

Ribbon integrates with Hystrix for circuit breaker + fallback logic.

üìå API Gateway (Spring Cloud Gateway)
üîë Key Points

Purpose

Acts as a single entry point for all client requests.

Handles routing, load balancing, and cross-cutting concerns (security, logging, monitoring).

Routing

Defines how incoming requests should be routed to backend services.

Uses predicates (conditions like Path, Header, Query param, etc.) to decide the route.

Example:

spring:
  cloud:
    gateway:
      routes:
        - id: order-service
          uri: lb://ORDER-SERVICE
          predicates:
            - Path=/orders/**


‚Üí lb://ORDER-SERVICE integrates with Ribbon/Eureka for load balancing.

Filters

Pre Filters ‚Üí execute before the request is routed (authentication, logging, request validation).

Post Filters ‚Üí execute after the response is received (modify response, add headers, monitoring).

Example:

filters:
  - AddRequestHeader=X-Request-Source, Gateway
  - AddResponseHeader=X-Response-Time, System


Built-in Filters

AddRequestHeader, RewritePath, Retry, CircuitBreaker, etc.

Can create custom filters by implementing GatewayFilter or GlobalFilter.

Load Balancing with Gateway

Uses service discovery (lb://SERVICE-NAME) to automatically balance requests across service instances.

Ribbon (or Spring Cloud LoadBalancer in newer versions) works behind the scenes.

üìå Important Behaviors

Ribbon Behavior

Distributes requests among instances automatically.

Can retry requests if a server is down.

Keeps a cache of instances for performance.

Gateway Behavior

Centralized access point ‚Üí hides internal services.

Can enforce security policies (auth, rate limiting, IP restrictions).

Applies cross-cutting filters consistently across services.

Decouples client from service location & version changes.

Combined Setup

Eureka Server ‚Üí service registry.

Ribbon (in Gateway or client) ‚Üí load balancing.

Gateway ‚Üí smart routing + pre/post processing of requests.

‚úÖ In short:

Ribbon ensures traffic is spread across service instances (server-side LB).

API Gateway provides routing, filtering, and a centralized entry point with load balancing baked in.